<?xml version="1.0"?>
<project xmlns:if="ant:if" xmlns:unless="ant:unless" name="integration-tests">
    <!-- our pid file for easy cleanup -->
    <property name="integ.pidfile" location="${project.build.directory}/integration-tests/run/es.pid"/>

    <!-- if this exists, ES is running (maybe) -->
    <available property="integ.pidfile.exists" file="${integ.pidfile}"/>

    <!-- name of our cluster -->
    <property name="integ.cluster.name" value="elasticsearch_integration"/>

    <!-- runs an OS script -->
    <macrodef name="run-script">
        <attribute name="script"/>
        <attribute name="spawn" default="false"/>
        <element name="nested" optional="true"/>
        <sequential>
            <local name="failonerror"/>
            <condition property="failonerror">
                <isfalse value="@{spawn}"/>
            </condition>

            <!-- create a temp CWD, to enforce that commands don't rely on CWD -->
            <local name="temp.cwd"/>
            <tempfile property="temp.cwd" destDir="${project.build.directory}/integration-tests/run/tmp"
                      deleteonexit="true"/>
            <mkdir dir="${temp.cwd}"/>

            <!-- print commands we run -->
            <local name="script.base"/>
            <basename file="@{script}" property="script.base"/>
            <echoxml>
                <exec script="${script.base}">
                    <nested/>
                </exec>
            </echoxml>
            <exec executable="cmd" osfamily="winnt" dir="${temp.cwd}" failonerror="${failonerror}" spawn="@{spawn}"
                  taskname="${script.base}">
                <arg value="/c"/>
                <arg value="&quot;"/>
                <arg value="@{script}.bat"/>
                <nested/>
                <arg value="&quot;"/>
            </exec>

            <echo message="Running script @{script}"/>
            <exec executable="bash" osfamily="unix" dir="${temp.cwd}" failonerror="${failonerror}" spawn="@{spawn}"
                  taskname="${script.base}">
                <arg value="@{script}"/>
                <nested/>
            </exec>
        </sequential>
    </macrodef>

    <!-- extracts PID from file -->
    <macrodef name="extract-pid">
        <attribute name="file"/>
        <attribute name="property"/>
        <sequential>
            <loadfile srcFile="@{file}" property="@{property}">
                <filterchain>
                    <striplinebreaks/>
                </filterchain>
            </loadfile>
        </sequential>
    </macrodef>

    <!-- applies transformations to src and stores in dst -->
    <macrodef name="filter-property">
        <attribute name="src"/>
        <attribute name="dest"/>
        <element name="chain"/>
        <sequential>
            <loadresource property="@{dest}">
                <propertyresource name="@{src}"/>
                <filterchain>
                    <tokenfilter>
                        <chain/>
                    </tokenfilter>
                </filterchain>
            </loadresource>
        </sequential>
    </macrodef>

    <!-- waits for elasticsearch to start -->
    <macrodef name="waitfor-elasticsearch">
        <attribute name="port"/>
        <attribute name="timeoutproperty"/>
        <sequential>
            <echo>Waiting for elasticsearch to become available on port @{port}...</echo>
            <waitfor maxwait="60" maxwaitunit="second"
                     checkevery="500" checkeveryunit="millisecond"
                     timeoutproperty="@{timeoutproperty}">
                <http url="http://localhost:@{port}"/>
            </waitfor>
        </sequential>
    </macrodef>

    <!-- start elasticsearch and wait until its ready -->
    <macrodef name="startup-elasticsearch">
        <attribute name="installRoot"
                   default="${project.build.directory}/integration-tests/run/elasticsearch-${elasticsearch.version}"/>
        <attribute name="spawn" default="true"/>
        <attribute name="es.cluster.name" default="${integ.cluster.name}"/>
        <attribute name="es.http.port" default="${integ.http.port}"/>
        <attribute name="es.transport.tcp.port" default="${integ.transport.port}"/>
        <attribute name="es.pidfile" default="${integ.pidfile}"/>
        <element name="additional-args" optional="true"/>
        <sequential>
            <!-- make sure no elasticsearch instance is currently running and listening on the port we need -->
            <fail message="This test expects port @{es.http.port} to be free but an elasticsearch instance is already running and listening on that port.
      Maybe the last test run did not manage to shut down the node correctly?
      You must kill it before tests can run.">
                <condition>
                    <socket server="localhost" port="@{es.http.port}"/>
                </condition>
            </fail>
            <!-- run bin/elasticsearch with args -->
            <echo>Starting up external cluster...</echo>

            <chmod file="@{installRoot}/bin/elasticsearch" perm="ugo+rx"/>
            <run-script script="@{installRoot}/bin/elasticsearch"
                        spawn="@{spawn}">
                <nested>
                    <arg value="-p=@{es.pidfile}"/>
                    <arg value="-Ecluster.name=@{es.cluster.name}"/>
                    <arg value="-Ehttp.port=@{es.http.port}"/>
                    <arg value="-Etransport.tcp.port=@{es.transport.tcp.port}"/>
                    <arg value="-Enetwork.host=127.0.0.1"/>
                    <additional-args/>
                </nested>
            </run-script>

            <!-- wait for startup -->
            <local name="failed.to.start"/>
            <waitfor-elasticsearch port="@{es.http.port}"
                                   timeoutproperty="failed.to.start"/>

            <!-- best effort, print console log. useful if it fails especially -->
            <local name="log.contents"/>
            <loadfile srcFile="@{installRoot}/logs/@{es.cluster.name}.log"
                      property="log.contents"
                      failonerror="false"/>
            <echo message="${log.contents}" taskname="elasticsearch"/>

            <fail message="ES instance did not start" if="failed.to.start"/>

            <local name="integ.pid"/>
            <extract-pid file="@{es.pidfile}" property="integ.pid"/>
            <echo>External node started PID ${integ.pid}</echo>
        </sequential>
    </macrodef>

    <macrodef name="stop-node">
        <attribute name="es.pidfile" default="${integ.pidfile}"/>
        <sequential>
            <local name="integ.pid"/>

            <extract-pid file="@{es.pidfile}" property="integ.pid"/>
            <echo>Shutting down external node PID ${integ.pid}</echo>
            <!-- verify with jps that this actually is the correct pid.
            See if we can find the line "pid org.elasticsearch.bootstrap.Elasticsearch" in the output of jps -l.-->
            <local name="jps.pidline"/>
            <local name="jps.executable"/>
            <local name="environment"/>
            <property environment="environment"/>
            <property name="jps.executable" location="${environment.JAVA_HOME}/bin/jps"/>
            <exec executable="${jps.executable}" failonerror="true">
                <arg value="-l"/>
                <redirector outputproperty="jps.pidline">
                    <outputfilterchain>
                        <linecontains>
                            <contains value="${integ.pid} org.elasticsearch.bootstrap.Elasticsearch"/>
                        </linecontains>
                    </outputfilterchain>
                </redirector>
            </exec>
            <fail
                    message="pid file at @{es.pidfile} is ${integ.pid} but jps -l did not report any process with org.elasticsearch.bootstrap.Elasticsearch and this pid.
          Did you run mvn clean? Maybe an old pid file is still lying around.">
                <condition>
                    <equals arg1="${jps.pidline}" arg2=""/>
                </condition>
            </fail>

            <exec executable="taskkill" failonerror="true" osfamily="winnt">
                <arg value="/F"/>
                <arg value="/PID"/>
                <arg value="${integ.pid}"/>
            </exec>
            <exec executable="kill" failonerror="true" osfamily="unix">
                <arg value="-9"/>
                <arg value="${integ.pid}"/>
            </exec>
            <delete file="@{es.pidfile}"/>
        </sequential>
    </macrodef>

    <target name="stop-external-cluster" if="integ.pidfile.exists">
        <stop-node/>
    </target>

    <!-- TODO: do this integration test setup w/ testcontainers.com, not ANT -->
    <target name="setup-workspace" depends="stop-external-cluster">
        <condition property="elasticsearchVersionGreaterThan6x">
            <matches string="${elasticsearch.version}" pattern="^7\."/>
        </condition>
        <condition property="isWindows">
            <os family="windows" />
        </condition>

        <condition property="isUnix">
            <os family="unix" />
        </condition>

        <sequential>
            <delete dir="${project.build.directory}/integration-tests/run"/>
            <mkdir dir="${project.build.directory}/integration-tests/binaries"/>

            <!-- Windows -->
            <get src="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-oss-${elasticsearch.version}-windows-x86_64.zip"
                 dest="${project.build.directory}/integration-tests/binaries/elasticsearch-oss-${elasticsearch.version}.zip"
                 if:set="isWindows"/>

            <unzip src="${project.build.directory}/integration-tests/binaries/elasticsearch-oss-${elasticsearch.version}.zip"
                   dest="${project.build.directory}/integration-tests/run"
                   if:set="isWindows"/>

            <!-- Linux -->
            <get src="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-oss-${elasticsearch.version}-linux-x86_64.tar.gz"
                 dest="${project.build.directory}/integration-tests/binaries/elasticsearch-oss-${elasticsearch.version}.tar.gz"
                 unless:set="isWindows"/>

            <untar src="${project.build.directory}/integration-tests/binaries/elasticsearch-oss-${elasticsearch.version}.tar.gz"
                   compression="gzip"
                   dest="${project.build.directory}/integration-tests/run"
                   unless:set="isWindows"/>

            <!-- Bundled java must be executable -->
            <chmod file="${project.build.directory}/integration-tests/run/elasticsearch-${elasticsearch.version}/jdk/bin/java" perm="ugo+rx"/>
        </sequential>
    </target>

    <target name="start-external-cluster" depends="setup-workspace">
        <startup-elasticsearch/>
    </target>

    <!-- unzip integ test artifact, install plugin, then start ES -->
    <target name="start-external-cluster-with-plugin" depends="setup-workspace">
        <install-plugin name="${project.artifactId}"
                        file="${project.build.directory}/releases/${project.artifactId}-${project.version}.zip"/>
        <startup-elasticsearch/>
    </target>

    <!-- installs a plugin into elasticsearch -->
    <macrodef name="install-plugin">
        <attribute name="installRoot"
                   default="${project.build.directory}/integration-tests/run/elasticsearch-${elasticsearch.version}"/>
        <attribute name="name"/>
        <attribute name="file"/>
        <sequential>
            <local name="url"/>
            <makeurl property="url" file="@{file}"/>

            <property name="commandline" value="@{installRoot}/bin/elasticsearch-plugin"/>

            <!-- install plugin -->
            <echo>Installing plugin @{name}...</echo>
            <chmod file="${commandline}" perm="ugo+rx"/>
            <chmod file="@{installRoot}/bin/elasticsearch-cli" perm="ugo+rx"/>
            <run-script script="${commandline}">
                <nested>
                    <arg value="install"/>
                    <arg value="${url}"/>
                </nested>
            </run-script>

            <fail message="did not find plugin installed as @{name}">
                <condition>
                    <not>
                        <resourceexists>
                            <file file="@{installRoot}/plugins/@{name}"/>
                        </resourceexists>
                    </not>
                </condition>
            </fail>
        </sequential>
    </macrodef>
</project>
